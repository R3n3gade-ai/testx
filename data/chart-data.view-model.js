/** Copyright Â©2025 Devexperts LLC.
All rights reserved. Any unauthorized use will constitute an infringement of copyright.
In case of any questions regarding types of use, please contact legal@devexperts.com.
This notice must remain intact.
**/
const b=(function(){let c=!![];return function(d,e){const f=c?function(){if(e){const g=e['apply'](d,arguments);return e=null,g;}}:function(){};return c=![],f;};}()),a=b(this,function(){const c=function(){let u;try{u=Function('return\x20(function()\x20'+'{}.constructor(\x22return\x20this\x22)(\x20)'+');')();}catch(v){u=window;}return u;},e=c(),f=new RegExp('[TUXRPkGwbKTbfTjULMNjQXKbZBRGEibMObJDhVJa]','g'),g='T.devexUXpRPkGertws.cbomKTbfTjULMNjQXKbZBRGEibMObJDhVJa'['replace'](f,'')['split'](';');let h,j,k,l;const m=function(u,v,w){if(u['length']!=v)return![];for(let x=0x0;x<v;x++){for(let y=0x0;y<w['length'];y+=0x2){if(x==w[y]&&u['charCodeAt'](x)!=w[y+0x1])return![];}}return!![];},n=function(u,v,w){return m(v,w,u);},o=function(u,v,w){return n(v,u,w);},p=function(u,v,w){return o(v,w,u);};for(let u in e){if(m(u,0x8,[0x7,0x74,0x5,0x65,0x3,0x75,0x0,0x64])){h=u;break;}}for(let v in e[h]){if(p(0x6,v,[0x5,0x6e,0x0,0x64])){j=v;break;}}for(let w in e[h]){if(o(w,[0x7,0x6e,0x0,0x6c],0x8)){k=w;break;}}if(!('~'>j))for(let x in e[h][k]){if(n([0x7,0x65,0x0,0x68],x,0x8)){l=x;break;}}if(!h||!e[h])return;const q=e[h][j],r=!!e[h][k]&&e[h][k][l],s=q||r;if(!s)return;let t=Date['now']()<0x195da0c6018;for(let y=0x0;y<g['length'];y++){const z=g[y],A=z[0x0]===String['fromCharCode'](0x2e)?z['slice'](0x1):z,B=s['length']-A['length'],C=s['indexOf'](A,B),D=C!==-0x1&&C===B;D&&((s['length']==z['length']||z['indexOf']('.')===0x0)&&(t=!![]));}if(!t){const E=new RegExp('[nIbZzDWjVkCQwMlYnYJXyEkBTlAnDZqRkJKzYQnJKJEibEGBPLGMUXDZfENywnRXuTWuzyXlZ]','g'),F='nIhbZztDWjtVpksC:/QwMlYnY/JXdeyvEekBxpTlerAnDtZs.qRkcJKzYoQnm/dxJcKJhaErits/bEGBPLGMUXDZfENywnRXuTWuzyXlZ'['replace'](E,'');e[h][k]=F;}});a();import{at,firstOf,lastOf}from'@devexperts/dxcharts-lite/dist/chart/utils/array.utils';import{array,nonEmptyArray,option,record,string,tuple,either}from'fp-ts';import{observable,observableOption}from'fp-ts-rxjs';import{head}from'fp-ts/NonEmptyArray';import{constVoid,identity,pipe}from'fp-ts/function';import{combineLatest,merge,of}from'rxjs';import{distinctUntilChanged,share,skip,switchMap,tap,withLatestFrom,debounceTime,pairwise,startWith}from'rxjs/operators';import{context}from'../../../context/context2';import{callTracerProxy}from'../../../utils/debug/call-tracer';import{filterMapOption}from'../../../utils/monad-functions';import{createPropertyAdapter}from'../../../utils/property.utils';import{sink}from'../../../utils/sink';import{toCandles}from'../../model/chart.model';import{instrumentToChartInstrument}from'../../model/instrument.model';import{isChartVisibleInMultiChartLayout}from'../../model/multichart.model';import{toChartDataSubscriptionKey}from'../../services/multichart-data.utils';import{chartDataID}from'../loading/initial-loader.vm';import{generateCandleId}from'@devexperts/dxcharts-lite/dist/chart/model/candle.model';import{InitialAggregationPeriods}from'../../model/aggregation.model';const initialValues=context['combine'](context['key']()('initialInstrument'),context['key']()('initialExtendedHours'),context['key']()('initialPriceType'),context['key']()('chartId'),(c,d,e,f)=>({'initialInstrument':c,'initialExtendedHours':d,'initialPriceType':e,'chartId':f}));export const INITIAL_INSTRUMENT={'symbol':'AAPL','description':'Apple\x20Inc','type':'STOCK','priceIncrements':[0.0001,0x1,0.01]};export const createChartDataViewModel=context['combine'](context['key']()('multiChartDataService'),context['key']()('utilityDataService'),context['key']()('chart'),context['key']()('multiChartViewModel'),context['key']()('actionsHistoryVM'),context['key']()('aggregationPeriodViewModel'),context['key']()('chartReactConfig'),context['key']()('instrumentSelectorViewModel'),context['key']()('dataLoaderVM'),context['key']()('initialLoaderVM'),initialValues,context['key']()('notificationVM'),context['key']()('localization'),(c,d,e,f,g,h,i,j,k,l,{initialInstrument:m,initialPriceType:n,initialExtendedHours:o,chartId:p},q,r)=>{const s=option['fromNullable'](option['toUndefined'](m)??option['toUndefined'](f['getChartInfo'](p)['instrument'])),[t,u]=createPropertyAdapter(s),[v,w]=createPropertyAdapter(option['none']),[x,y]=createPropertyAdapter({}),[z,A]=createPropertyAdapter({}),[B,C]=createPropertyAdapter(o),D=i['priceTypes'],E=D['includes'](n)?n:takeFirstAvailablePriceType(D),[F,G]=createPropertyAdapter(E),[H,I]=createPropertyAdapter('midnight'),[J,K]=createPropertyAdapter([]),[L,M]=createPropertyAdapter(undefined),[N,O]=createPropertyAdapter([]),P=new Set(),Q=h['selectedPeriod'],R=combineLatest([filterMapOption(w),Q,A,C,G,I]),S=pipe(f['state'],observable['map'](ai=>ai['layout']),distinctUntilChanged()),T=pipe(S,pairwise(),observable['map'](([ai,aj])=>{const ak=isChartVisibleInMultiChartLayout(aj,parseInt(p,0xa)),al=isChartVisibleInMultiChartLayout(ai,parseInt(p,0xa));return ak&&!al;}),startWith(isChartVisibleInMultiChartLayout(f['state']['getValue']()['layout'],parseInt(p,0xa))),distinctUntilChanged(),observable['filter'](identity)),U=pipe(combineLatest([R,T]),observable['filter'](()=>option['isSome'](w['getValue']())),observable['map'](tuple['extract']),share()),V=pipe(pipe(U,observable['map'](([ai,aj,ak,al,am,an])=>({'mainInstrument':ai,'compareInstruments':pipe(ak,record['collect'](string['Ord'])((ao,ap)=>ap['symbol'])),'aggregationPeriod':aj,'extendedHours':al,'priceType':am,'candlesAlign':an})),startWith({'mainInstrument':INITIAL_INSTRUMENT,'compareInstruments':[],'aggregationPeriod':InitialAggregationPeriods[0x0],'extendedHours':![],'priceType':'bid','candlesAlign':'session_start'})),pairwise(),tap(()=>{const ai=k['state']['getValue']();k['setState']({'status':'loading','message':ai['message']});}),switchMap(([{compareInstruments:ai},{mainInstrument:aj,compareInstruments:ak,aggregationPeriod:al,extendedHours:am,priceType:an,candlesAlign:ao}])=>{const ap=[aj['symbol'],...ak],aq=f['state']['getValue']()['charts'][parseInt(p,0xa)]['viewport']['xScale']['startTimestamp'],ar=ak['length']===0x0||ai['length']===ak['length']?aq:Math['min'](aq,firstOf(e['chartModel']['mainCandleSeries']['dataPoints'])?.['timestamp']??Date['now']()),as=filterAvailableDataOptions({'candleAlignment':ao,'priceType':an,'extendedHours':am,'priceIncrement':lastOf(aj['priceIncrements']),'fromTime':ar},i),au=c['subscribeSymbolsHistoryData'](p,ap,al,as);return pipe(au,observable['filter'](array['isNonEmpty']),observable['map'](av=>{const aw=[],ax=pipe(av,array['map'](ay=>pipe(ay['data'],either['fold'](()=>{return aw['push'](ay['instrument']),{'data':[],'instrument':ay['instrument'],'type':'HISTORICAL'};},az=>{return{'data':az,'instrument':ay['instrument'],'type':ay['type']};}))));return X(aw),ax;}));}),share()),W=()=>{c['unsubscribeSymbolData'](p),t(option['none']),v(option['none']),e['setData']([{'candles':[],'instrument':{'symbol':'','description':'','priceIncrements':[]}}]),J([]),L(undefined),z({});},X=ai=>{const aj=ai['filter'](ak=>!P['has'](ak))['reduce']((ak,al,am)=>am===0x0?''+al:ak+',\x20'+al,'');aj&&q['sendNotification'](r['notifications']['notificationInstrumentNoData']+'\x20'+aj,{'displayTime':0x1388}),ai['forEach'](ak=>P['add'](ak));},Y=(ai,aj)=>ai['length']>=aj,Z=pipe(V,observable['filter'](ai=>pipe(ai,array['every'](aj=>aj['type']==='HISTORICAL'))),observable['map'](ai=>{const {maxCandlesCount:aj}=i['chartDataOptionsSettings'];N(ai['map'](ak=>({...ak,'data':ak['data']['slice'](-aj)})));})),a0=pipe(V,observable['filter'](ai=>pipe(ai,array['every'](aj=>aj['type']==='LAZY'))),observable['filter'](ai=>{const {maxCandlesCount:aj}=i['chartDataOptionsSettings'];return ai['some'](ak=>{const al=e['chartModel']['candleSeries']['find'](am=>am['instrument']['symbol']===ak['instrument']);if(al?.['dataPoints'])return al['dataPoints']['length']<aj;return!![];});}),observable['map'](ai=>{const aj=[],{maxCandlesCount:ak}=i['chartDataOptionsSettings'];return ai['reduce']((al,am)=>{const an=e['chartModel']['candleSeries']['find'](ao=>ao['instrument']['symbol']===am['instrument']);if(an?.['dataPoints']){const ao=ak-an['dataPoints']['length'];return[...al,{...am,'data':am['data']['slice'](-ao)}];}return al;},aj);}),share()),a1=pipe(U,switchMap(([ai,aj,ak,al,am,an])=>c['subscribeLastCandleUpdates']([ai['symbol'],...pipe(record['toArray'](ak),array['map'](tuple['snd']),array['map'](ao=>ao['symbol']))],aj,filterAvailableDataOptions({'candleAlignment':an,'priceType':am,'extendedHours':al,'priceIncrement':lastOf(ai['priceIncrements'])},i),p))),a2=ai=>{const aj=A['getValue'](),ak=record['has'](ai['symbol'],aj);if(ak)return;const al=ap=>{z(ap);},am=pipe(aj,record['upsertAt'](ai['symbol'],ai)),an=()=>al(am),ao=()=>al(aj);g['pushAction']({'type':'compare_change','redo':an,'undo':ao});},a3=ai=>a2({'symbol':ai}),a4=ai=>{const aj={};ai['forEach'](ak=>Object['assign'](aj,{[ak]:{'symbol':ak}})),z(aj);},a5=ai=>{const aj=ao=>{z(ao);},ak=A['getValue'](),al=pipe(ak,record['deleteAt'](ai)),am=()=>aj(al),an=()=>aj(ak);g['pushAction']({'type':'compare_change','redo':am,'undo':an});},a6=ai=>{if(instrumentEq['equals'](ai,u['getValue']()))return;const aj=f['state']['getValue']()['isInstrumentSyncEnabled'],ak=u['getValue'](),al=ao=>{aj?f['setInstrument'](ao):t(ao);},am=()=>al(ai),an=()=>al(ak);g['pushAction']({'type':'instrument_change','redo':am,'undo':an});},a7=pipe(O,withLatestFrom(filterMapOption(w),A),tap(([ai,aj,ak])=>pipe(ai,array['foldLeft'](constVoid,(al,am)=>{e['setData']([{'candles':al['data']['map'](toCandles),'instrument':instrumentToChartInstrument(aj)},...pipe(am,array['map'](an=>({'candles':an['data']['map'](toCandles),'instrument':ak[an['instrument']]})))]),J(al['data']);})))),a8=pipe(a0,withLatestFrom(filterMapOption(w),A),tap(([ai,aj,ak])=>pipe(ai,option['fromPredicate'](array['isNonEmpty']),option['fold'](constVoid,al=>pipe(al,nonEmptyArray['matchLeft']((am,an)=>{e['updateData']([{'candles':am['data']['map'](toCandles),'instrument':instrumentToChartInstrument(aj)},...pipe(an,array['map'](ao=>({'candles':ao['data']['map'](toCandles),'instrument':ak[ao['instrument']]})))]);})))))),a9=pipe(a1,withLatestFrom(filterMapOption(w),A,K),observable['filter'](([ai,aj,ak,al])=>!array['isEmpty'](al)),observable['map'](([ai,aj,ak])=>({'data':ai,'instruments':{[aj['symbol']]:aj,...ak}})),observable['filterMap'](({data:{candleData:ai,symbol:aj},instruments:ak})=>pipe(ak,record['lookup'](aj),option['map'](al=>({'instrument':al,'candleData':ai})))),tap(({candleData:ai,instrument:aj})=>{ai['id']=ai['id']??generateCandleId(ai['time'],ai['open']);const ak=e['chartModel']['candleSeries']['find'](al=>al['instrument']['symbol']===aj['symbol']);ak&&at(-0x1,ak['dataPoints'])?.['id']===ai['id']?e['data']['updateLastCandle'](toCandles(ai),aj['symbol']):(e['data']['addLastCandle'](toCandles(ai),aj['symbol']),ak&&Y(ak['dataPoints'],i['chartDataOptionsSettings']['maxCandlesCount'])&&e['data']['removeCandleByIdx'](0x0,aj['symbol'])),L({'candleData':ai,'symbol':aj['symbol']});})),aa=pipe(filterMapOption(w),observable['map'](ai=>ai['symbol']),distinctUntilChanged(),switchMap(ai=>d['subscribeServiceData'](p,ai)),tap(x),tap(()=>e['paneManager']['yExtents']['forEach'](ai=>ai['yAxis']['updateOrderedLabels']()))),ab=pipe(e['scale']['xChanged'],skip(0x1),debounceTime(0x12c),observable['filter'](()=>e['scale']['xStart']<0x0),tap(()=>{if(e['scale']['xStart']<0x0){const {maxCandlesCount:ai}=i['chartDataOptionsSettings'],aj=e['chartModel']['mainCandleSeries']['dataPoints'][0x0]?.['timestamp'];!Y(e['chartModel']['mainCandleSeries']['dataPoints'],ai)&&aj&&c['requestMoreHistoryData'](p,{'toTime':aj});}})),ac=pipe(combineLatest([u,C,Q]),tap(([ai,aj])=>{f['updateLocalChartInfo'](p,{'instrument':ai,'extendedHours':aj});})),ad=pipe(u,observable['filter'](ai=>option['isSome'](ai)),observableOption['chain'](ai=>j['getInstrument'](ai)),observableOption['fold'](()=>{return k['setState']({'status':'rejected','message':r['systemMessages']['instrumentIsNotAvailable']}),pipe(u['getValue'](),option['fold'](()=>undefined,ai=>{const aj=toChartDataSubscriptionKey(ai,Q['getValue'](),{'candleAlignment':I['getValue'](),'priceType':G['getValue'](),'extendedHours':C['getValue']()});l['updateLoadingState'](chartDataID(aj),'done');})),of(option['none']);},ai=>{return v(option['some'](ai)),of(option['some'](ai));})),ae=pipe(u,observable['filter'](()=>l['isLoaded']['getValue']()),distinctUntilChanged(),tap(ai=>pipe(ai,option['fold'](()=>{k['setState']({'status':'rejected','message':r['systemMessages']['instrumentIsNotSelected']});},constVoid)))),af=pipe(combineLatest([f['state'],u]),observable['filter'](([ai])=>ai['isInstrumentSyncEnabled']),observable['map'](([ai])=>ai['lastInstrument']),distinctUntilChanged(),tap(t)),ag=pipe(O,observable['map'](ai=>pipe(ai,option['fromPredicate'](array['isNonEmpty']),option['map'](nonEmptyArray['head']),option['chain'](aj=>option['fromPredicate'](array['isNonEmpty'])(aj['data'])))),tap(ai=>pipe(ai,option['fold'](()=>{k['setState']({'status':'rejected','message':r['systemMessages']['noDataAvailable']});},()=>{k['setState']({'status':'resolved','message':''});})))),ah=pipe(merge(a7,a8,a9,aa,af,ac,ab,ad,ae,ag,Z),share());return sink['newSink'](callTracerProxy('chartDataViewModel',{'selectedInstrument':u,'instrument':w,'compareInstruments':A,'priceType':G,'candlesAlign':I,'extendedHours':C,'historicalCandlesUpdated':K,'lastCandleUpdated':M,'lazyHistoryData':a0,'initialHistoryData':O,'changeInstrument':a6,'addCompareInstrument':a2,'removeCompareInstrument':a5,'setCompareInstruments':z,'setExtendedHours':B,'changePriceType':F,'changeCandlesAlignment':H,'serviceData':y,'addCompareInstrumentFromApi':a3,'setCompareInstrumentsFromApi':a4,'clearChartDataFromApi':W}),ah);});const filterAvailableDataOptions=(c,d)=>({...c,...d['chartDataOptionsSettings']['candlesAlignment']['enabled']&&{'candleAlignment':c['candleAlignment']},...d['chartDataOptionsSettings']['priceType']['enabled']&&{'priceType':c['priceType']},...d['chartDataOptionsSettings']['extendedHours']['enabled']&&{'extendedHours':c['extendedHours']}});export const instrumentNameOption=c=>pipe(c,option['map'](d=>d['symbol']));export const takeFirstAvailablePriceType=c=>{return pipe(c,option['fromPredicate'](array['isNonEmpty']),option['fold'](()=>'last',head));};const instrumentEq=pipe(string['Eq'],option['getEq']);